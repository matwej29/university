###############################################################################
# Небольшая мультипрограммная система, имеющая только два задания.
# Задания могут находиться в следующих состояниях: RUNNING, READY или WAITING.
# 
###############################################################################


###############################################################################
# MAIN
###############################################################################

	.globl main
	.text

main:
	j boot 


###############################################################################
# BOOT
#
# Инициализация простой системы мультипрограммирования.
###############################################################################

	.text
	
boot:
	# Включить прерывания клавиатуры. 
	
  	lw  $t0, RECEIVER_CONTROL	# Адрес регистра управления приемником.
  	lw  $t1, 0($t0)				# Значение регистра управления приемником.
  	ori $t2, $t1, 2				# Установка бита разрешения прерывания в 1.
  	sw  $t2, 0($t0)				# Обновление регистра управления приемником. 
 	
        # В MARS при запуске регистр состояния устанавливается в 0x0000ff11, т.е,
        # бит разрешения прерывания (бит 0) уже установлен, и 
        # установлены биты маски прерывания (биты 8-15).

	# Инициализация структур данных ядра.
		
	# В контексте задания значение программного счетчика ($pc) хранится по 
	# смещению 0. 
	
	# В контексте job 0 PC будет указывать на начало задания 0
	
	la $t0, __job_0_context
	la $t1, job_increment
	sw $t1, 0($t0)
	
	# В контексте job 1 PC будет указывать на начало задания 1
	
	la $t0, __job_1_context
	la $t1, job_getc
	sw $t1, 0($t0)
	
	# Job 1 начинает выполняться
	
	li $t0, 1
	sw $t0, __running
	
	# Job 0 в состоянии готовности
	
	li $t0, 0
	sw $t0, __ready

	# Начинаем выполнять задание, находящееся в состоянии выполнения
	
	# Получаем id задания (jid), которое сейчас выполняется 
	
	lw $t0, __running 
	
	# Смещение указателя контекста (0 или 4)  = jid * 4
	
	sll $t1, $t0, 2   # jid * 4
	
	# Указатель на контекст выполняемого задания.
	
	lw $t3, __context_array($t1)
	
	# Получаем значение программного счетчика из контекста по смещению 0. 
	
	lw $t4, 0($t3)

	# Переход по адресу в $t4. 
	
	jr $t4


###############################################################################
# USER DATA SEGMENT
#
# Данные, используемые заданиями пользовательского уровня. 
###############################################################################

	.data

# Строки, используемые заданиями для печати сообщений. 

JOB_GETC_HELLO:		    .asciiz "Job started running getc\n"
JOB_INCREMENT_HELLO:	.asciiz "Job started running increment\n"

JOB_ID:			        .asciiz "Job id = "
NL:			            .asciiz "\n"

PRESS_KEY:		        .asciiz "Press a key on the keyboard ...\n"
PRESS_MMIO_KEY:		    .asciiz "Type a character in the MMIO Simulator keyboard input area ..\n"
PRESS_MMIO_STRING:		    .asciiz "Type a string in the MMIO Simulator keyboard input area ..\n"

# В этих строках символ X находится по смещению 17 от начала строки и будет заменен перед печатью. 

MARS_GETC_RESULT: 	    .asciiz "\nMARS   getc ==> X\n"
CUSTOM_GETC_RESULT: 	.asciiz "\nCustom getc ==> X\n"
CUSTOM_GETS_RESULT: 	.asciiz "\nCustom gets ==> \n"
NEW_LINE:               .asciiz "\n"

# Адреса памяти для регистров приемника, отображаемых в памяти. 
RECEIVER_CONTROL:	.word 0xffff0000
RECEIVER_DATA:		.word 0xffff0004

buffer: .space 128
	
###############################################################################
# НЕ ЗАВЕРШАЮЩИЕСЯ ЗАДАНИЯ ПОЛЬЗОВАТЕЛЬСКОГО УРОВНЯ
#
# Задания должны быть не завершающимися.
#
# Заданиям разрешено использовать только следующие регистры: $v0, $a0, $a1 и $s0.
###############################################################################
	
	.text
	
#------------------------------------------------------------------------------
# INCREMENT
#
# Задание на уровне пользователя. 
#------------------------------------------------------------------------------

job_increment:
	
	# Для печати строки используем встроенный системный вызов MARS (4).
	
	li $v0, 4
	la $a0, JOB_INCREMENT_HELLO
	syscall 

	# Для печати строки используем встроенный системный вызов MARS (4).
	
	li $v0, 4
	la $a0, JOB_ID
	syscall

	# Используем пользовательский системный вызов (getjid, системный вызов 0),
	# чтобы получить идентификатор этого задания. 
	
	li $v0, 0
	teqi $zero, 0
	
	# Теперь $a0 содержит идентификатор задания. 
	
	# Используем встроенный системный вызов MARS (1), чтобы вывести идентификатор (целое число).
	
	li $v0, 1
	syscall

	# Для печати строки используем встроенный системный вызов MARS (4).
	
	li $v0, 4
	la $a0, NL
	syscall
	
	# Печать завершена.
	
	# Инициализируем $s0.
	
	li $s0, 0
	
	# Входим в бесконечный цикл, в котором $s0 постоянно увеличивается. 

job_increment_infinite_loop:
	addi $s0, $s0, 1
	j job_increment_infinite_loop
	

#------------------------------------------------------------------------------
# GETC
#
# Задание на уровне пользователя
#------------------------------------------------------------------------------

job_getc:
	
	# Для печати строк используем встроенный системный вызов MARS (4).
	
	li $v0, 4               # Код системного вызова (4) - печать строки. 
	la $a0, JOB_GETC_HELLO  # Строка, которая будет напечатана.
	syscall 				# Выполнение встроенного системного вызова MARS (4) для печати строки.
	
	# Для печати строк используем встроенный системный вызов MARS (4).
	
	li $v0, 4
	la $a0, JOB_ID
	syscall
	
	# Используем пользовательский системный вызов (getjid, системный вызов 0), чтобы получить идентификатор этого задания. 
	
	li $v0, 0				# Пользовательский системный вызов с кодом 0 (getjid).
	teqi $zero, 0   		# Генерируем исключение-ловушку для обработки системного вызова.
	
	# Теперь $a0 содержит идентификатор задания. 
	
	# Используем встроенный системный вызов MARS (1), чтобы вывести идентификатор (целое число).

	li $v0, 1
	syscall

	# Для печати строки используем встроенный системный вызов MARS (4).
	
	li $v0, 4
	la $a0, NL
	syscall

	# Для печати строки используем встроенный системный вызов MARS (4).
	
	li $v0, 4               
	la $a0, PRESS_KEY       
	syscall 				

	# Используем встроенную версию системного вызова getc
	
	li $v0, 12		# Код системного вызова (12) - read_char.
	syscall 		
	
	# ASCII-значение нажатой клавиши теперь в $v0

	# Для печати строк используем встроенный системный вызов MARS (4).
	
	sb $v0, MARS_GETC_RESULT + 17  # вместо Х записываем введенный символ
	li $v0, 4
	la $a0, MARS_GETC_RESULT
	syscall 
	
	# Записываем в $s0 значение 0xabcd1234.
	# поменять ab или 34 на свой номер
	li $s0, 0x19cd1234
 
	# Входим в бесконечный цикл. 
	
job_getc_infinite_loop:
#TODO_10: # вывести содержимое $s0 в 16-м формате
	li $v0, 34
    	move $a0, $s0
    	syscall # тут?
    	
    			
	# Для печати строки используем встроенный системный вызов MARS (4).
	
	li $v0, 4               # Код системного вызова (4) печать строки. 	
	la $a0, PRESS_MMIO_KEY  # Строка для печати.
	syscall 				

	# Выполняем пользовательский системный вызов getc (системный вызов 12).
	li $v0, 12
	teqi $zero, 0    
	
	# ASCII-значение нажатой клавиши теперь в $v0
	
	# Для печати строки используем встроенный системный вызов MARS (4).

	sb $v0, CUSTOM_GETC_RESULT + 17
	li $v0, 4
	la $a0, CUSTOM_GETC_RESULT
	syscall 
	
	li $v0, 4               # Код системного вызова (4) печать строки. 	
	la $a0, PRESS_MMIO_STRING  # Строка для печати.
	syscall 
		
	# Вызов gets
	li $v0, 8
	la $a0, buffer
	li $a1, 8
	teqi $zero, 0
	
	li $v0, 4
	la $a0, CUSTOM_GETS_RESULT
	syscall
	
	# Печать строки
	li $v0, 4            # Код print_string
	la $a0, buffer       # Адрес буфера
	syscall
	
	li $v0, 4
	la $a0, NEW_LINE
	syscall
	
	j job_getc_infinite_loop

###############################################################################
# KERNEL DATA SEGMENT
#
# Данные, используемые обработчиком исключений и прерываний, т.е. данные
# используемые ядром.
###############################################################################

		.kdata

# При входе в ядро значения всех регистров, используемых при выполнении задания
# должны быть сохранены в памяти. Позже, когда работа возобновится, значения регистров
# восстанавливаются из памяти.  

# Содержимое всех регистров, используемых заданием, называется контекстом. 

# В этой упрощенной системе каждому заданию разрешено использовать только шесть
# регистров: $pc (программный счетчик), $v0, $a0, $a0, $s0 и $at. Каждый регистр по
# четыре байта, следовательно, 6*4 = 24 байта памяти требуется каждому заданию для хранения
# своего контекста.

__job_0_context: .space 24 
__job_1_context: .space 24

# Массив указателей на контекст заданий. Job id используется как индекс. 

__context_array:   __job_0_context
                 , __job_1_context

# Для каждого из состояний храним -1, если в данный момент в этом состоянии нет какого-либо задания,
# или храним идентификатор задания (0 или 1), которое в данный момент находится в этом состоянии. 
__running: 	.word -1 # ID задания в состоянии выполнения.
__ready: 	.word -1 # ID задания в состоянии готовности.
__waiting:	.word -1 # ID задания в состоянии ожидания до завершения I/O. 

# Выделяем место для хранения стека ядра. Стек растет от старших адресов
# в сторону младших адресов.

__kernel_stack_bottom: 		.space 128 # Сначала выделяется 128 байт. 
__kernel_initial_stack_top:	.space 4   # Выделение еще четырех байт. 

# Регистр $at (временный регистр ассемблера) обычно резервируется для использования в
# псевдоинструкции. Загрузка адресов меток (la) и использование меток при
# загрузке (lw) или хранении (sw) являются примерами псевдоинструкций, которые
# будут переведены в базовые инструкции с помощью $at.

# Чтобы ядро могло использовать псевдоинструкции без
# повреждения значения $at выполняемого задания, значение $at должно быть сначала
# сохранено в памяти. Позже сохраненное значение будет записано в контекст
# задания, которое выполнялось при входе в ядро.

# Выделение места для временного сохранения $at. 

__at:	.word 0

# Первоначально $sp будет установлен по адресу __kernel_stack_top и
# будет расти вниз по направлению к __kernel_stack_bottom.

# Строки, используемые для вывода сообщений об ошибках ядра. 
	
__error_msg_1: .asciiz "ERROR: Unhandled exception (code "
__error_msg_2: .asciiz  ")\n"
__error_msg_3: .asciiz "ERROR: Unsuported system call (code "

__buffer_pointer: .word 4
__buffer_remaining: .word 0

__interrupt_mode: .word 0
# 0 - обрабатываем getc
# 1 - обрабатываем gets
		
###############################################################################
# ПОДПРОГРАММЫ ЯДРА
#
# Подпрограммы, используемые ядром.   
###############################################################################

		.ktext

#------------------------------------------------------------------------------
# ОПИСАНИЕ  
#
# Возвращает идентификатор задания и контекстный адрес запущенного задания. 
# 
#
# АРГУМЕНТЫ 
# 
# Нет.
#
# 
# ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
# 
# $k0 - Идентификатор выполняемого задания. 
# $k1 - Указатель на контекст.
# 			
#------------------------------------------------------------------------------  
__get_running_job:
         
	# Идентификатор (jid) выполняемого задания.
	
	lw $k0, __running
	
	# Смещение: __context_array = jid * 4
	
	sll $k1, $k0, 2         # Умножаем на 4.
	
	# Получаем указатель на контекст из массива __context_array.
	
    lw $k1, __context_array($k1)  
           	    
	jr $ra    


#------------------------------------------------------------------------------
# ОПИСАНИЕ
#
# Сохраняет контекст (регистры) выполняемого задания.
# 
# АРГУМНЕТЫ
# 
# Нет.
#
# ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
#
# Нет.
#------------------------------------------------------------------------------
__save_running_job_context:

	# сохраняем адрес возврата из функции в стеке
	
	addi $sp, $sp, -4  
	sw   $ra, 0($sp)   
       	
	# Получаем информацию о выполняемом задании.
       	
	jal __get_running_job
	
	# $k0 - ID выполняемого задания
	# $k1 - Адрес структуры, содержащей контекст выполняемого задания  

	# Получаем значение EPC.
 
 	mfc0 $k0, $14
 			
 	# Сохраняем значения регистров в структуре контекста. 
 	 
	sw $k0,   0($k1)	# PC
	sw $v0    4($k1)	# $v0
	
#TODO_1: # Сохраните $a0, $a1, $s0 в структуре контекста. 
	
	sw $a0, 8($k1)
	sw $a1, 12($k1)
	sw $s0, 16($k1)
        	
	
	lw $a0, __at            # NOTE: $at был сохранен в памяти при входе в ядро!
	sw $a0, 20($k1)         # $at
	
	# Извлекаем адрес возврата.
	
	lw $ra, 0($sp)
	addi $sp, $sp, 4	
	
	jr	$ra

#------------------------------------------------------------------------------
# ОПИСАНИЕ
# 
# Восстановление контекста (регистров) задания.
# 
# АРГУМЕНТ 
#
# $k0 - id задания. 
#------------------------------------------------------------------------------
__restore_job_context:
	
	# Используем идентификатор задания для индексации массива __context_array
	
	sll $k0, $k0, 2 # id * 4
	
	# Используем (id*4) для индексации массива __context_array.
	
	lw $k0, __context_array($k0)      
	
	# Восстанавливаем регистры. 

	lw $k1,  0($k0) # PC
	lw $v0,  4($k0) # $v0
	
#TODO_2: # Восстановите $a0, $a1, $s0 из контекста.
	
	lw $a0, 8($k0)
	lw $a1, 12($k0)
	lw $s0, 16($k0)
	
	# NOTE: $at может все еще использоваться ядром и будет восстановлен позже, непосредственно перед
	# выходом из режима ядра. 

	# Установите EPC в сопроцессоре 0 на значение PC, считанное из контекста. 
	
	mtc0 $k1, $14		
	
	jr $ra
	
	

###############################################################################
# KERNEL TEXT SEGMENT
# 
# Ядро обрабатывает все исключения, прерывания и пользовательские системные вызовы.
###############################################################################
   	
   	# Адрес вектора исключений для MIPS32.
   	.ktext 0x80000180	
   
__kernel:

      	# Чтобы сделать возможным использование ядром псевдоинструкций и
      	# подпрограмм, не повреждая значения регистров $at и $ra 
      	# выполняемого задания, значения $at и $ra должны быть сначала сохранены в памяти.
      	# Позже сохраненные значения будут записаны в контекст задания.
      	# которое выполнялось при входе в ядро.
      	
 	# NOTE: Инструкция sw - это псевдоинструкция, использующая $at.
	# Чтобы сохранить текущее значение $at, сначала нужно скопировать значение
	# $at в $k1. 

	move $k1, $at		# Копирование значения $at в $k1.

	# Теперь значение $at может быть сохранено в памяти.
	sw $k1, __at      	   

	# Регистры $k0 и $k1 должны использоваться только в обработчике исключений,
	# поэтому могут быть использованы без сохранения и восстановления.
		
	# Инициализация стека ядра. 
	
	la $sp, __kernel_initial_stack_top
	
	# Сохраняем контекст выполняемого задания. 
	
	jal __save_running_job_context
	
	# Теперь ядро может использовать следующие регистры: $v0, $a0, $s0, $k0 и $k1.
   	
   	# Мы вошли в ядро - из-за исключения или из-за прерывания?
   	
   	# Получаем значение из регистра Cause в сопроцессоре 0. 
 	
 	mfc0 $k0, $13
 	
 	# Извлекаем код исключения (биты 2 - 6).          
   	
   	srl $k1, $k0, 2        
   	andi $k1, $k1, 0x1f
	
	# Для всех прерываний код исключения == 0.   

   	beqz $k1, __interrupt
	
	# Ненулевое значение означает, что это исключение. 
	
__exception:
	
	# $k0 - CAUSE
   	# $k1 - Код исключения
   	
   	# Единственное исключение, обрабатываемое ядром, - это исключение TRAP с 
   	# кодом исключения 13.   
   	
  	li $k0, 13   
   	bne $k1, $k0, __unhandled_exception
   	
__trap_handler:

   	# Код обработчика исключения ловушки. 
   	
   	jal __get_running_job
	
	# $k0 - идентификатор (ID) выполняемого задания
	# $k1 - адрес структуры состояния выполняемой задачи
	
	# Переход на код обработки системного вызова, который лежит в $v0. 
	
   	beqz $v0, __system_call_getjid
   	
#TODO_3: # Перейдите на метку __system_call_getc - обработка системного вызова с кодом 12.
	beq $v0, 12, __system_call_getc
	
	beq $v0, 8, __system_call_gets
	
   	
   	j __unsported_system_call
 
 __system_call_getjid: 
	
	# Неблокирующий системный вызов
	
	# В $k0 уже содержится jid выполняемого задания.

	jal __restore_job_context

#TODO_4: # Записываем jid в регистр $a0.
	# TIP: Ядро сохранило jid выполняемого задания в памяти по метке __running
        lw $a0, __running	
	
	j __return_from_exception
   	  	
__system_call_getc:
	# Установка режима прерываний с клавиатуры
	li $t0, 0
	sw $t0, __interrupt_mode
	
	# На данный момент: 
	#   $k0 - Идентификатор выполняемого задания.
	#   $k1 - Адрес контекста выполняемого задания.
	
	# Чтение символа с клавиатуры - это БЛОКИРУЮЩИЙ системный вызов. 
	# Блокируем выполняемое задание путем изменения его состояния на ожидание.
			
	sw $k0, __waiting
	
	# Чтобы иметь возможность возобновить выполнение позже, необходимо сохранить адрес, по которому
	# продолжить выполнение, как только будет готов запрошенный с клавиатуры символ.
	
#TODO_5:	# Получите адрес инструкции (teqi), вызвавшей исключение.
	# и сохраните его в $t0.
	
	# TIP: Когда происходит исключение (или прерывание), адрес последней
	# выполненной инструкции сохраняется в EPC (Exception Program Counter).
	# регистр в сопроцессоре 0. Регистр EPC - это $14 сопроцессора 0.
	
	# TIP: Используйте инструкцию mfc0 (Move FRom Coprocessor 0), чтобы получить значение
	# EPC.
	
	mfc0 $t0, $14
	
	# Если возобновить выполнение с инструкции по адресу в EPC, то это приведет к повторному выполнению той же самой инструкции
	# (teqi), которая использовалась для инициирования	пользовательского системного вызова.

	# Каждая инструкция занимает 4 байта. 

	
#TODO_6:	# Возобновить выполнение инструкции, следующей за инструкцией teqi.
	# Для этого, прибавьте 4 к EPC и сохраните результат в $t1.
	
	# TIP: Используйте инструкцию addi (Add Immediate). 
	addi $t1, $t0, 4
	
#TODO_7:	# Теперь значение EPC + 4 должно быть сохранено в контексте выполняемого задания.
	# TIP: В контексте поле, используемое для хранения значения для возобновления, находится по адресу
	# со смещением 0. 
			
	# TIP: Теперь $t1 должен содержать EPC + 4.
	
	# TIP: В $k1 уже содержится адрес контекста выполняемого задания.

	# TIP: Используйте инструкцию sw (Store Word) для сохранения содержимого EPC + 4 ($t1).
	# Сохраните EPC + 4 в пользовательском контексте по смещению 0 (счетчик программы). 
	sw $t1, 0($k1)
		
	# Идентификатор задания, которое должно быть возобновлено, пока задание, запросившее системный вызов
	# находится в состоянии	ожидания.
   	lw $k0, __ready 
   	
   	# Установите EPC на значение PC, сохраненное в контексте выбранного задания.
   	# Индекс контекста задания находится в массиве __context_array
   	
   	sll $t0, $k0, 2 	# (job id) * 4 
   	
   	# Получение адреса контекста задания.
   	
   	lw $t1 __context_array($t0) 
   	
   	# Получение значения PC из контекста.
   	
   	lw $t2, 0($t1)	# PC находится на смещении 0
   	
   	# Установите ECP на восстановленное значение PC.
   	   	
	mtc0 $t2, $14   # Обновление EPC
	
	# Измените статус выбранного задания на выполняемое. 
	
	sw $k0, __running
	

	# Восстановление контекста.
	
	jal __restore_job_context
	
	# Восстановление $at. 
	
	lw $at, 20($k0)

	# NOTE: С этого момента никакие псевдоинструкции не могут быть использованы. 
	
	# Возобновление выполнения по адресу, сохраненному в EPC.
	
	eret
__system_call_gets:
	# Устанавливаем режим прерывания для того, чтобы различать случай, когда нужно вызвать обработчик для getc
	# а когда для gets
	li $t0, 1
	sw $t0, __interrupt_mode

	# На данный момент: 
	#   $k0 - Идентификатор выполняемого задания.
	#   $k1 - Адрес контекста выполняемого задания.
	lw $a0, 8($k1)
	lw $a1, 12($k1)
	
	# Сохраняем полученные аргументы в память для дальнейшего использования
	sw $a0, __buffer_pointer
	subi $a1, $a1, 1 # Сразу же отнимаем единицу, чтобы оставить место под \0
	sw $a1, __buffer_remaining

	# Аналогично getc, помечаем программу как ожидающую и передаем управление другому процессу
	sw $k0, __waiting
	mfc0 $t0, $14

	addi $t1, $t0, 4

	sw $t1, 0($k1)

   	lw $k0, __ready 

   	sll $t0, $k0, 2 	# (job id) * 4 
 
   	lw $t1 __context_array($t0) 

   	lw $t2, 0($t1)
   	
	mtc0 $t2, $14

	sw $k0, __running

	
	jal __restore_job_context
	
	lw $at, 20($k0)

	eret
   	
__unsported_system_call:

	li $v0, 4
	la $a0, __error_msg_3
	syscall 
	
	li $v0, 1
	move $a0, $k0	
   	syscall 
   	
   	li $v0, 4
   	la $a0, __error_msg_2
   	syscall 
   	
   	j __return_from_exception
   	
__unhandled_exception:

	li $v0, 4
	la $a0, __error_msg_1
	syscall
	
	li $v0, 1
	move $a0, $k1	
	syscall
	
	li $v0, 4
	la $a0, __error_msg_2
	syscall 
		
	j __return_from_exception

__return_from_exception:
 
	# Пропустить инструкцию, вызвавшую исключение
   
    #TODO_	 
	
   	# Передача управления по адресу в EPC.
   	
   	mfc0 $k0, $14        # Получение EPC
	addi $k0, $k0, 4     # Пропустить инструкцию, вызвавшую исключение
	mtc0 $k0, $14
   	
   	eret
   	
__interrupt:

	# Отключаем все прерывания на время обработки.
	
	# Загружаем STATUS ($12) из сопроцессора 0.
	
	mfc0 $t0, $12
	
	# Нулевой бит (разрешение прерывания) в STATUS устанавливаем на 0
	
	li $t1, 0xfffe
	and $t0, $t0, $t1
	
	# Обновляем STATUS ($12) в сопроцессоре 0.
	
	mtc0 $t0, $12 
	
	# Что за прерывание?
	
	# MARS Аппаратное прерывание уровня 1 (клавиатура)
	
	li $k1, 0x00000100
		
	bne $k0, $k1, __return_from_interrupt
	
__kbd_interrupt:

	# Игнорируем прерывание, если ни одно задание не ожидает завершения системного вызова getc.
	
	lw $k0, __waiting
	li $k1, -1
	beq $k0, $k1, __return_from_interrupt
	
	lw $k1, __interrupt_mode
	beq $k1, 0, __getc_system_call_pending
	beq $k1, 1, __gets_system_call_pending

	j __return_from_interrupt
	
	
__getc_system_call_pending:
	
	# Есть задание, которое ожидает I/O.
	
	# Меняем местами ожидающую и выполняющуюся задачу
	
	lw $k0, __waiting
	lw $k1, __running
	sw $k0, __running
	
	# Никакое задание не находится больше в состоянии ожидания. 
	
	li $t0, -1
	sw $t0, __waiting
	
	# $k0 содержит идентификатор задания, ожидающего ввода. Восстанавливаем контекст этого задания.
	jal __restore_job_context

	# Получаем ASCII-значение нажатой клавиши и сохраняем его в $k1.
	
	# Регистр данных , отображаемый в памяти, находится по адресу 0xffff0004.
	
	li $k1, 0xffff0004
	
#TODO_8:	# Прежде чем возобновить выполнение задания, введем ASCII-значение нажатой кнопки
	# в регистр $v0
	# TIP: $k1 содержит адрес регистра данных приемника, отображаемого в памяти.
	
	# TIP: Используйте инструкцию (Load Word) для чтения значения ASCII в $v0. 
	lw $v0, 0($k1)

#TODO_9: # Добавьте код для отображения введенного символа в MMIO симуляторе	
	li $t0, 0xffff000c
	sw $v0, 0($t0)
	# Восстанавливаем $at.
	
	lw $at, 20($k0) 

	# NOTE: С этого момента никакие псевдоинструкции не могут быть использованы.
	
	# Закончив обработку прерывания, разрешаем все прерывания.
	
	# Получение содержимого регистра STATUS.  
	
	mfc0 $k0, $12
	
	# Нулевой бит (разрешение прерывания) устанавливаем в 1.
	
	li $k1, 1
	or $k0, $k0, $k1
	
	# Обновляем регистр STATUS.
	
	mtc0 $k0, $12 
	
	# Возобновление выполнения ожидающего задания. Инструкция eret устанавливает значение $pc
	# в значение EPC.
	
	eret

__gets_system_call_pending:
	# Загружаем введеный символ в k1
	lw $k1, 0xffff0004
	# Загружаем указатель на буфер и остаток
	lw $t0, __buffer_pointer
	lw $t1, __buffer_remaining

	# Проверка на Enter (ascii 10)
	li $t2, 10
	beq $k1, $t2, __gets_system_call_exit

	# Проверка на заполнение буфера
	blez $t1, __gets_system_call_exit

	# Записать символ в буфер
	sb $k1, ($t0)
	addi $t0, $t0, 1
	addi $t1, $t1, -1
	sw $t0, __buffer_pointer
	sw $t1, __buffer_remaining
	
	# Вывести символ тут же на дисплей
	#li $t0, 0xffff000c
	#sw $k1, 0($t0)
	
		
	mfc0 $k0, $12
	
	# Нулевой бит (разрешение прерывания) устанавливаем в 1.
	
	li $k1, 1
	or $k0, $k0, $k1
	
	# Обновляем регистр STATUS.
	
	mtc0 $k0, $12 

	j __return_from_interrupt

__gets_system_call_exit:
	# Добавить нулевой терминатор
	sb $zero, 0($t0)
	li $t0, 0
	sw $t0, __interrupt_mode      # Сбросить режим
	# Разблокировать задание
	
	lw $k0, __waiting
	lw $k1, __running
	sw $k0, __running
	
	# Никакое задание не находится больше в состоянии ожидания. 
	
	li $t0, -1
	sw $t0, __waiting
	
	# $k0 содержит идентификатор задания, ожидающего ввода. Восстанавливаем контекст этого задания.
	jal __restore_job_context

	lw $at, 20($k0) 
	
	mfc0 $k0, $12
	
	# Нулевой бит (разрешение прерывания) устанавливаем в 1.
	
	li $k1, 1
	or $k0, $k0, $k1
	
	# Обновляем регистр STATUS.
	
	mtc0 $k0, $12 


	j __return_from_interrupt


__return_from_interrupt:
    # Возвращение. Надо установить PC на значение в $14 (EPC).
   	eret
   


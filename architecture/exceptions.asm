###############################################################################
# Знакомство с обработкой исключений и прерываний в Mips. 
#
# 2024-10-25
# 
###############################################################################


###############################################################################
# USER TEXT SEGMENT
#
# MARS начинает выполняться по метке main в пользовательском сегменте .text.
###############################################################################

			.globl main
			.text
main:
       	# Максимальное 32-битное положительное число в доп. коде.
	
	li $s0, 0x7fffffff  
	
	# Инициирование исключения арифметического переполнения.  
       	
       	addi $s1, $s0, 1
	
	# Вызовет исключение, связанное с обращением к недопустимому адресу данных.
	
	lw $s0, 0($zero)
	
	# Инструкция teqi (Trap EQual Immediate) используется для условного запуска
	# исключения-ловушки (код исключения 13),
	# которое автоматически передает управление ядру.
	
	teqi $zero, 0

todo_3:
	# Включить прерывания клавиатуры. 
	
	# Получение значения регистра управления приемником, отображаемого в памяти
  	
  	lw $s0, 0xffff0000	

	# Todo: Установите первый бит (разрешение прерывания) в блоке управления приемником в 1
	
	# TIP 1: Биты нумеруются с нуля. Нужен бит с номером 1.
	
	# TIP 2: Используйте битовую маску 0x2 = 0000 ..... 0010
	
	# TIP 3: Используйте инструкцию ORI и сохраните результат в регистре $s1
	
        
 	# Обновите регистр управления приемником
 	
 	ori $s1, 0x2
 	
        sw $s1, 0xffff0000
        sw $s1, 0xffff0008
        
        # Замечание: Если вы используете Mars, то при запуске регистр состояния устанавливается
		# в 0x0000ff11, т.е. бит разрешения прерывания (бит 0) уже установлен, а все биты маски
		# прерывания (биты 8-15) установлены в 1. 
	
	
infinite_loop: 
	
	# Этот бесконечный цикл имитирует работу процессора, например выполнение другого
	# задания в ожидании ввода данных с клавиатуры пользователя. 
	
	addi $s0, $s0, 1
	j infinite_loop


###############################################################################
# KERNEL DATA SEGMENT
###############################################################################

		.kdata
		
UNHANDLED_EXCEPTION:	.asciiz "===>      Unhandled exception       <===\n\n"
UNHANDLED_INTERRUPT: 	.asciiz "===>      Unhandled interrupt       <===\n\n"
OVERFLOW_EXCEPTION: 	.asciiz "===>      Arithmetic overflow       <===\n\n" 
TRAP_EXCEPTION: 	    .asciiz "===>         Trap exception         <===\n\n"
BAD_ADDRESS_EXCEPTION: 	.asciiz "===>   Bad data address exception   <===\n\n"
		
###############################################################################
# KERNEL TEXT SEGMENT 
# 
# Ядро обрабатывает все исключения и прерывания.
# 
# Регистры $k0 и $k1 никогда не должны использоваться программами пользовательского
# уровня и могут использоваться исключительно ядром. 
#
# В реальной системе ядро должно следить за тем, чтобы значения используемых регистров 
# сохранять в памяти перед использованием. Позже, перед возобновлением выполнения 
# программы пользовательского уровня, ядро должно восстановить значения регистров из памяти 
# 
# Обратите внимание, что если ядро использует любую псевдоинструкцию, которая транслируется
# в инструкцию с использованием регистра $at, то это может помешать программам пользовательского
# уровня, использующим $at. В реальной системе ядро должно также сохранять и восстанавливать
# значение $at. 
# 
# Для простоты в этом ядре не будут сохраняться и восстанавливаться значения регистров. 
# Вместо этого ядро может свободно использовать любые регистры, кроме $s0, который используется 
# в бесконечном цикле пользовательской программы для имитации выполняющейся программы. 
###############################################################################

   		# Адрес начала обработчика исключений в MIPS32.
   		.ktext 0x80000180  

__kernel_entry_point:

	# Получение значения из регистра cause
	
	mfc0 $k0, $13
	
	# Установка всех битов в нулевое значение, кроме кода исключения (биты 2 - 6).
	
	andi $k1, $k0, 0x00007c  
	
	# Сдвиг двух бит вправо для получени кода исключения
	
	srl  $k1, $k1, 2
	
	# Теперь $k0 = значению регистра cause
	#        $k1 = значению код исключения (exception code)
	
	# Код исключения равен нулю для прерывания и не равен нулю для всех исключений 
	
	beqz $k1, __interrupt
	
__exception:

	# Переход по значению кода исключения в $k1 
	
	beq $k1, 12, __overflow_exception
	
todo_2:	
	# TODO: Добавьте код для перехода на метку __bad_address_exception для кода исключения 4 	
	beq $k1, 4, __bad_address_exception
	# TODO: Добавьте код для перехода на метку __trap_exception для кода исключения 13 
	beq $k1, 13, __trap_exception
	
__unhandled_exception: 
    	
  	#  Используем встроенный в MARS системный вызов 4 (печать строки) для вывода сообщения об ошибке
	
	li $v0, 4
	la $a0, UNHANDLED_EXCEPTION
	syscall
 
 	j __resume_from_exception
	
__overflow_exception:

  	#  Используем встроенный в MARS системный вызов 4 (печать строки) для вывода сообщения об ошибке
	
	li $v0, 4
	la $a0, OVERFLOW_EXCEPTION
	syscall
 
 	j __resume_from_exception
 	
 __bad_address_exception:

  	#  Используем встроенный в MARS системный вызов 4 (печать строки) для вывода сообщения об ошибке
	
	li $v0, 4
	la $a0, BAD_ADDRESS_EXCEPTION
	syscall
 
 	j __resume_from_exception	
 
__trap_exception: 

  	#  Используем встроенный в MARS системный вызов 4 (печать строки) для вывода сообщения об ошибке
	
	li $v0, 4
	la $a0, TRAP_EXCEPTION
	syscall
 
 	j __resume_from_exception

__interrupt: 

	# Значение регистра cause получено ранее и записано в $k0
	
	# Обнуляем все биты, кроме восьмого (interrupt pending) 
    	
    	andi $k1, $k0, 0x00000100
    	
    	# Сдвиг вправо на 8, чтобы получить значение бита
    	srl  $k1, $k1, 8
    	
    	# Переход в зависимости от значения полученного бита 
    	
    	beq  $k1, 1, __keyboard_interrupt

__unhandled_interrupt: 
   
  	#  Используем встроенный в MARS системный вызов 4 (печать строки) для вывода сообщения об ошибке
	
	li $v0, 4
	la $a0, UNHANDLED_INTERRUPT
	syscall
 
 	j __resume

__keyboard_interrupt:     	
	
	# Получение ASCII-значения нажатой клавиши из регистра данных приемника, отображаемого в памяти

todo_4:
	# Сохраните содержимое регистра данных приемника, отображенного в памяти, в $k1
	
	lw $k1, 0xffff0004 # TODO: Снимите комментарий с этой инструкции
	sw $k1, 0xffff000c

	# Используйте встроенный системный вызов MARS 11 (печать символа) для печати символа 
	# из регистра данных приемника
	
	move $a0, $k1 # TODO: Снимите комментарий с этой инструкции
	li $v0, 11    # TODO: Снимите комментарий с этой инструкции
	syscall       # TODO: Снимите комментарий с этой инструкции
	
	j __resume
	

__resume_from_exception: 
	
	# Когда возникает исключение или прерывание, значение программного счетчика 
	# ($pc) программы пользовательского уровня автоматически сохраняется в программном счетчике исключений 
	# ECP (регистр $14 в сопроцессоре 0)
    # Получение значения из регистра EPC (адрес инструкции, вызвавшей исключение)
       
        
        mfc0 $k0, $14
        
        
todo_1:
        # Пропустите инструкцию, которая вызвала исключение. Для этого, надо добавить 4 к значению, хранящемуся в EPC. 
		# В противном случае управление опять будет передано на инструкцию, вызвавшую исключение
        
        addi $k0, $k0, 4 # TODO: Снимите комментарий с этой инструкции   
       
        # Обновить регистр EPC в сопроцессоре 0
        
        mtc0 $k0, $14
        
__resume:
            
	# Используйте инструкцию eret (Exception RETurn) для установки программного счетчика 
	# (PC) на значение, сохраненное в регистре ECP (регистр 14 в сопроцессоре 0)
	
	eret # Перед выполнением инструкции в пошаговом режиме посмотрите на значение регистра $14 в сопроцессоре 0
